{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Lesson 4: More operators and conditionals\n",
    "\n",
    "<hr/>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In this lesson, we will examine more operators beyond the arithmetic and assignment operators we have already encountered. We will look at **relational operators**, **identity operators**, and **logical operators**. We'll use these operators in **conditional statements**, which help a program decide what to do in certain situations."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Relational operators\n",
    "\n",
    "Suppose we want to compare the values of two numbers.  We may want to know if they are equal for example. The operator used to test for equality is `==`, an example of a **relational operator** (also called a **comparison operator**)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### The equality relational operator\n",
    "\n",
    "Let's test out the `==` to see how it works."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 1,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "5 == 5"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "5 == 4"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Notice that using the operator gives either `True` or `False`. These are important keywords in Python that indicate truth. `True` and `False` have a special type, called `bool`, short for **Boolean**."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "bool"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "type(True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "bool"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "type(False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The equality operator, like all relational operators in Python, also works with variables, testing for equality of their *values*. Equality of the variables themselves uses **identity operators**, described [below](#Identity-operators)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a = 4\n",
    "b = 5\n",
    "c = 4\n",
    "\n",
    "a == b"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a == c"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now, let's try it out with some floats."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "5.3 == 5.3"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "2.1 + 3.2 == 5.3"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Yikes! Python is telling us that `2.1 + 3.2` is not `5.3`. This is floating point arithmetic haunting us. Note that floating point numbers that can be exactly represented with binary numbers do not have this problem."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "2.2 + 3.2 == 5.4"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This behavior is unpredictable, so here is a rule.\n",
    "\n",
    "<div style=\"color: tomato; text-align: center; font-weight: bold;\">\n",
    "\n",
    "Never use the <font font-family=\"monospace\">==</font> operator with floats.\n",
    "    \n",
    "</div>\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Other relational operators\n",
    "\n",
    "As you might expect, there are other relational operators.  The relational operators are\n",
    "\n",
    "|English|Python|\n",
    "|:-------|:----------:|\n",
    "|is equal to | `==`|\n",
    "|is not equal to | `!=`|\n",
    "|is greater than | `>`|\n",
    "|is less than | `<`|\n",
    "|is greater than or equal to | `>=`|\n",
    "|is less than or equal to | `<=`|\n",
    "\n",
    "We can try some of them out!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "4 < 5"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "5.7 <= 3"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "'michael jordan' > 'lebron james'"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Whoa. What happened on that last one?  The Python interpreter has weighed in on the debate about the greatest basketball player of all time. It clearly thinks Michael Jordan is better than LeBron James, but that seems kind of subjective. To understand what the interpreter is doing, we need to understand how it compares strings."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### A brief aside on Unicode\n",
    "\n",
    "In Python, characters are encoded with [Unicode](https://en.wikipedia.org/wiki/Unicode). This is a standardized library of characters from many languages around the world that contains over 100,000 characters. Each character has a unique number associated with it. We can access what number is assigned to a character using Python's built-in `ord()` function."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "97"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "ord('a')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "955"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "ord('Î»')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The relational operators on characters compare the values that the `ord` function returns. So, using a relational operator on `'a'` and `'b'` means you are comparing `ord('a')` and `ord('b')`. When comparing strings, the interpreter first compares the first character of each string. If they are equal, it compares the second character, and so on. So, the reason that `'michael jordan' > 'lebron james'` gives a value of `True` is because `ord('m') > ord('l')`.\n",
    "\n",
    "Note that a result of this scheme is that testing for equality of strings means that **all** characters must be equal. This is the most common use case for relational operators with strings."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "'lebron' == 'lebron james'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "'lebron' == 'LeBron'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "'LeBron James' == 'LeBron James'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "'AGTCACAGTA' == 'AGTCACAGCA'"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Chaining relational operators\n",
    "\n",
    "Python allow chaining of relational operators."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "4 < 6 < 6.1 < 9.3"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "4 < 6.1 < 6 < 9.3"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This is convenient do to. However, it is important not to do the following, even though it is legal."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "4 < 6.1 > 5"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In other words, do not mix the direction of the relational operators. You could run into trouble because, in this case, `5` and `4` are never compared. An expression with different relations among all three numbers also returns `True`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "4 < 6.1 > 3"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "So, I issue a warning.\n",
    "\n",
    "<div style=\"color: tomato; text-align: center; font-weight: bold;\">\n",
    "\n",
    "Do not mix the directions of chained relational operators.\n",
    "    \n",
    "</div>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Identity operators\n",
    "\n",
    "Identity operators check to see if two variables occupy the same space in memory; i.e., they are the same object (we'll learn more about objects as we go along in the bootcamp). This is different that the equality relational operator, `==`, which checks to see if two variables have the same **value**. The two identity operators are in the table below.\n",
    "\n",
    "|English|Python|\n",
    "|:-------|:----------:|\n",
    "|is the same object | **`is`**|\n",
    "|is not the same object | **`is not`**|\n",
    "\n",
    "That's right. The operators are pretty much the same as English! Let's see these operators in action and get at the difference between `==` and `is`. Let's use the **`is`** operator to investigate how Python stored variables in memory, starting with `float`s."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(True, False)"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a = 5.6\n",
    "b = 5.6\n",
    "\n",
    "a == b, a is b"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Even though `a` and `b` have the same value, they are stored in different places in memory. They can occupy the same place in memory if we do a `b = a` assignment."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(True, True)"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a = 5.6\n",
    "b = a\n",
    "\n",
    "a == b, a is b"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Because we assigned `b = a`, they necessarily have the same (immutable) value. So, the two variables occupy the same place in memory for efficiency."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(False, False)"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a = 5.6\n",
    "b = a\n",
    "a = 6.1\n",
    "\n",
    "a == b, a is b"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In the last two examples, we see that assigning `b = a`, where `a` is a `float` in this case, means that `a` and `b` occupy the same memory. However, reassigning the value of `a` resulted in the interpreter placing `a` in a new space in memory. We can double check the values.\n",
    "\n",
    "Integers sometimes do not behave the same way, however."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(True, True)"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a = 5\n",
    "b = 5\n",
    "\n",
    "a == b, a is b"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Even though we assigned `a` and `b` separately, they occupy the same place in memory. This is because Python employs **integer caching** for all integers between `-5` and `256`. This caching does not happen for more negative or larger integers."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 27,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a = 350\n",
    "b = 350\n",
    "\n",
    "a is b"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now, let's look at strings."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(True, False)"
      ]
     },
     "execution_count": 28,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a = 'Hello, world.'\n",
    "b = 'Hello, world.'\n",
    "\n",
    "a == b, a is b"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "So, even though `a` and `b` have the same *value*, they do not occupy the same place in memory. If we do a `b = a` assignment, we get similar results as with `float`s."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(True, True)"
      ]
     },
     "execution_count": 29,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a = 'Hello, world.'\n",
    "b = a\n",
    "\n",
    "a == b, a is b"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's try string assignment again with a different string."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(True, True)"
      ]
     },
     "execution_count": 30,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a = 'python'\n",
    "b = 'python'\n",
    "\n",
    "a == b, a is b"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Wait a minute! If we choose a string `'python'`, it occupies the same place in memory as another variable with the same value, but that was not the case for `'Hello, world.'`. This is a result of Python also doing [**string interning**](https://en.wikipedia.org/wiki/String_interning) which allows for (sometimes very) efficient string processing. Whether two strings occupy the same place in memory depends on what the strings are.\n",
    "\n",
    "The caching and interning might be a problem, but you generally do not need to worry about it for **immutable** variables. Being immutable means that once the variables are created, their values cannot be changed. If we do change the value the variable gets a new place in memory. All variables we've encountered so far, `int`s, `float`s, and `str`s, are immutable. We will see encounter mutable data types in future lesson, in which case it really *does* matter practically to you as a programmer whether or not two variables are in the same location in memory."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Logical operators\n",
    "\n",
    "**Logical operators** can be used to connect relational and identity operators. Python has three logical operators.\n",
    "\n",
    "|Logic|Python|\n",
    "|:-------|:----------:|\n",
    "|AND | `and`|\n",
    "|OR | `or`|\n",
    "|NOT | `not`|\n",
    "\n",
    "The `and` operator means that if both operands are `True`, return `True`. The `or` operator gives `True` if *either* of the operands are `True`. Finally, the `not` operator negates the logical result.\n",
    "\n",
    "That might be as clear as mud to you. It is easier to learn this, as usual, by example."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 31,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "True and True"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 32,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "True and False"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 33,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "True or False"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 34,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "True or True"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 35,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "not False and True"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 36,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "not(False and True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 37,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "not False or True"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 38,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "not (False or True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 39,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "7 == 7 or 7.6 == 9.1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 40,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "7 == 7 and 7.6 == 9.1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "I think these examples will help you get the hang of it. Note that it is important to specify the ordering of your operations, particularly when using the `not` operator.\n",
    "\n",
    "Note also that\n",
    "\n",
    "    a < b < c\n",
    "    \n",
    "is equivalent to\n",
    "\n",
    "    (a < b) and (b < c)\n",
    "\n",
    "With these new types of operators in hand, we can construct a more complete table of operator precedence.\n",
    "\n",
    "|precedence|operators|\n",
    "|:-------|:----------:|\n",
    "|1 | `**`|\n",
    "|2 | `*`, `/`, `//`, `%`|\n",
    "|3 | `+`, `-`|\n",
    "|4 | `<`, `>`, `<=`, `>=`|\n",
    "|5 | `==`, `!=`|\n",
    "|6 | `=`, `+=`, `-=`, `*=`, `/=`, `**=`, `%=`, `//=`|\n",
    "|7 | `is`, `is not`|\n",
    "|8 | `and`, `or`, `not`|"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Operators we left out\n",
    "\n",
    "We have left out a few operators in Python. Two that we left out are the **membership operators**, `in` and `not in`, which we will visit in a forthcoming lesson. The others we left out are **bitwise operators** and operators on **sets**, which we will not be covering in the bootcamp."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## The numerical values of True and False\n",
    "\n",
    "As we move to conditionals, it is important to take a moment to evaluate the numerical values of the keywords `True` and `False`.  They have numerical values of `1` and `0`, respectively."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 41,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "True == 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 42,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "False == 0"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "You can do arithmetic on `True` and `False`, but you will get implicit type conversion."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1"
      ]
     },
     "execution_count": 43,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "True + False"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "int"
      ]
     },
     "execution_count": 44,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "type(True + False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Conditionals\n",
    "\n",
    "**Conditionals** are used to tell your computer to do a set of instructions depending on whether or not a Boolean is `True`. In other words, we are telling the computer:\n",
    "\n",
    "    if something is true:\n",
    "        do task a\n",
    "    otherwise:\n",
    "        do task b\n",
    "\n",
    "In fact, the syntax in Python is almost exactly the same. As an example, let's ask whether or not a codon is the canonical start codon (`AUG`)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "This codon is the start codon.\n"
     ]
    }
   ],
   "source": [
    "codon = 'AUG'\n",
    "\n",
    "if codon == 'AUG':\n",
    "    print('This codon is the start codon.')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The syntax of the `if` statement is apparent in the above example. The Boolean expression, `codon == 'AUG'`, is called the **condition**. If it is `True`, the indented statement below it is executed. This brings up a very important aspect of Python syntax.\n",
    "\n",
    "<div style=\"color: dodgerblue; text-align: center; font-weight: bold;\">\n",
    "\n",
    "Indentation matters.\n",
    "    \n",
    "</div>\n",
    "\n",
    "Any lines with the same level of indentation will be evaluated together."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "This codon is the start codon.\n",
      "Same level of intentation, so still printed!\n"
     ]
    }
   ],
   "source": [
    "codon = 'AUG'\n",
    "\n",
    "if codon == 'AUG':\n",
    "    print('This codon is the start codon.')\n",
    "    print('Same level of intentation, so still printed!')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "What happens if our codon is not the start codon?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [],
   "source": [
    "codon = 'AGG'\n",
    "\n",
    "if codon == 'AUG':\n",
    "    print('This codon is the start codon.')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Nothing is printed. This is because we did not tell Python what to do if the Boolean expression `codon == 'AUG'` evaluated `False`. We can add that with an `else` **clause** in the conditional."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "This codon is not the start codon.\n"
     ]
    }
   ],
   "source": [
    "codon = 'AGG'\n",
    "\n",
    "if codon == 'AUG':\n",
    "    print('This codon is the start codon.')\n",
    "else:\n",
    "    print('This codon is not the start codon.')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Great! Now, we have a construction that can choose which action to take depending on a value. So, if we're zooming along an RNA sequence, we could pick out the start codon and infer where translation would start. Now, what if we want to know if we hit a canonical stop codon (`UAA`, `UAG`, or `UGA`)?  We can nest the conditionals!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "This codon is a stop codon.\n"
     ]
    }
   ],
   "source": [
    "codon = 'UAG'\n",
    "\n",
    "if codon == 'AUG':\n",
    "    print('This codon is the start codon.')\n",
    "else:\n",
    "    if codon == 'UAA' or codon == 'UAG' or codon == 'UGA':\n",
    "        print('This codon is a stop codon.')\n",
    "    else:\n",
    "        print('This codon is neither a start nor stop codon.')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Notice that the indentation defines which clause the statement belongs to. E.g., the second `if` statement is executed as part of the first `else` clause.\n",
    "\n",
    "While this nesting is very nice, we can be more concise by using an `elif` clause."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "This codon is neither a start nor stop codon.\n"
     ]
    }
   ],
   "source": [
    "codon = 'UGG'\n",
    "\n",
    "if codon == 'AUG':\n",
    "    print('This codon is the start codon.')\n",
    "elif codon == 'UAA' or codon == 'UAG' or codon == 'UGA':\n",
    "    print('This codon is a stop codon.')\n",
    "else:\n",
    "    print('This codon is neither a start nor stop codon.')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Computing environment"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Python implementation: CPython\n",
      "Python version       : 3.11.3\n",
      "IPython version      : 8.12.0\n",
      "\n",
      "jupyterlab: 3.6.3\n",
      "\n"
     ]
    }
   ],
   "source": [
    "%load_ext watermark\n",
    "%watermark -v -p jupyterlab"
   ]
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
